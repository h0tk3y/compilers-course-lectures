Семантика малого шага. Раньше было отношение -(s)-> subset C^2.
Теперь введём c-(s)->c'->(s')-> -- с остаточными вычислениями.
То есть, в семантике мы будем указывать, какие ещё вычисления нужно выполнить для данной конфигурации.

В нашей семантике мы теперь будем говорить не о полном выполнении оператора, а о том, чтобы для оператора выполнить примитивное действие.

Семантика малого шага фактически является надмножеством семантики большого шага, потому что в записи c-(s)->c'->(s')-> может отсутствовать продолжение ->(s')->.
Для примитивных операторов у нас ничего не изменится, четыре аксиомы останутся без изменений.

	[Seq_SS]

	    c -(s1)-> c' -(s1')->
	------------------------------
	c -(s1; s2)-> c' -(s1'; s2) ->

	[Seq_empty_SS]

	     c -(s1)-> c'
	-------------------------
	c -(s1; s2)-> c' -(s2)->

	[IfFalse_SS]

	------------------------------------- [|e|] s == 0
	c -(if e then s1 else s2)-> c -(s2)->

	[IfTrue_SS]

	------------------------------------- [|e|] s != 0
	c -(if e then s1 else s2)-> c -(s1)->

	[While]

	---------------------------------------------------------------------
	c -(while e do s)-> c -(if e == 0 then skip else (s; while e do s))->

Для доказательств с такой семантикой подходит индукция по числу шагов в продолжении.

// Для лямбда-исчисления есть денотационная семантика, и построение её с нужными свойствами было нетривиальной задачей.

Заданные семантики большого и малого шага эквивалентны, хотя это верно не для всех случаев.
Эквивалентность показывается с помощью рассмотрения операторов на произвольных конфигурациях.

	c -(s)->_BS c'  <=>  c -(s)->_SS* c'

Семантика малого шага даёт возможность по-другому рассуждать о программе: вместо начального и конечного состояния она связывает
начальное и _следующее_ состояния.

_Утверждение_ 

	Если c -s1;s2->(за k шагов) c', то можно найти такое i, что
		 c -s1->(за i шагов) c'' -(за k - i шагов) -> c'

	_Доказательство_ (индукция по числу шагов)

		База: если k = 2, то у нас два последовательных примитивных оператора, i = 1.

		Переход: если применяется [Seq_empty_SS], то делается ровно один шаг, и i = 1.
		Иначе мы переходим за один шаг мы переходим в c2' -(s1';s2)->, и тут мы пользуемся индукционным предположением, потому что
		в s1';s2 число шагов меньше.

А ещё семантика малого шага позволяет говорить о параллельных вычислениях: для двух потоков мы можем сказать, что мы выполним по одному шагу из каждого потока.
В семантике большого шага мы смогли бы только говорить о полной редукции сначала одной части, затем другой.

_Утверждение_

	Если c -(s1)->(за k шагов) c', то
		 c -(s1;s2)->(за k шагов) c' -(s2)->

	А в обратную сторону? Обязательно ли по первой части композиции мы попадём за k шагов в промежуточный результат, у которого продолжением была бы вторая часть?

		Контрпример: 
			x := 1; // s1
			while x > 3 do x := x + 1 // s2

			[] -(x := 1)-> [x -> 1] -(s2)->
			[] -(x := 1)-> [x -> 1] -(x := x+1; while ...)->
			[] -(x := 1)-> [x -> 1] -> [x -> 2] ->(while ...)->

			Тут мы получили за два шага c' -(s2)->, но мы не можем за два шага прийти в c' = [x -> 2] из [] с помощью (x := 1).
			Всё ломает раскрутка цикла.

Денотационная семантика

	Будем рассматривать на примере лямбда-исчисления

	Л := x | \x.Л | Л Л

	Суть денотационной семантики в том, что каждому объекту сопоставляется функция на домене.

	STLC (simply typed lambda calculus) -- синтаксис тот же, но появляются типы: 

		t ::= o | t -> t

		У каждой переменной теперь есть тип, и в термах появляются ограничения на типы.

		Не является Тьюринг-полным, на нём нельзя зациклиться.

	Для каждого типа заведём некоторый домен

		[|i|] = A_i

		[|sigma -> tau|] <-> A_(sigma -> tau) = A_tau^(A_sigma)
		[|sigma -> tau|] = все функции [A_sigma -> A_tau]

		Для термов
		rho : x^sigma -> A_sigma
		[|x^sigma|] rho = rho(x) in A_sigma

		[|\x^sigma . M^tau|] = \x.[|M|] rho
		                     = (a^sigma |-> [|M|] (rho [x := a]) -- эта семантика -- функция, которая берёт семантику тела абстракции и подставляет 

		[|M N|] rho = [|M|] rho ([|N|] rho)

		И, соответственно, имеют семантику у нас только термы, которые типизируются в STLC.

	Scott: модель семантики для лямбда-исчисления (с какой-то другой системой типов) и семантика для языка PCF. У него типы были t ::= o | i | t -> t.
	[|Y M|] = [|M|] [|Y M|] :: sigma
	Y :: (sigma -> sigma) -> sigma -> sigma, но для каждого sigma семантку нужно задавать отдельно.