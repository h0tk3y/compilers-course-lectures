Object code folding

    Вычисление в compile-time всех константных выражений. Достаточно обнаружить, что в потоке данных есть константа, и тогда можно итеративно распространить результат.

Перестановка операция с целью уменьшения количества тактов 
    
    Арифметические преобразования, степень => умножение, умножение => двоичный сдвиг

Лучше иметь возможность остановить анализ на некоторой глубине, потому что время компиляции обычно тоже хочется иметь небольшим.

Перестановка циклов

    Линеаризация для итерации по массиву для улучшения locality of reference.

Инверсия цикла

    while => if { do-while }, исчезает jump на проверку предусловия на последней итерации.

Loop combining/jammin
    
    Объединение/слияние циклов, идущих друг за другом с одинаковым количеством итераций, имеющих независимые тела
    (плюс, для двумерных массивов, можно уменьшить размер кода, если развернуть в одномерный цикл)

Loop fission

    В обратную сторону. Зачем -- открытый вопрос. (имхо, может увеличить локальность кода)

Вынос инвариантного кода в циклах

    Вынос за цикл всего, что можно посчитать один раз вместо каждой итерации.

// Многопоточность значительно ухудшает возможности для оптимизации, потому что даже простейшие становятся некорректными

Уменьшение стоимости операций

    for (i, ..., ++i) a[i] = 6 * i + 3   =>   for (i, k, ++i, k += 6) a[i] = k + 3 

    Плюс, замена операций на более дешёвые.

Статический анализ (анализ потока данных)

    Обычно точный анализ неразрешим, поэтому обычно нас интересует некоторая безопасная (корректная) аппроксимация ответа

    read(x)
    if (x > 0) y = 0
    else  { y = 1; S } // S doesn't change y
    z = y

    the value of z is in [0..1]
    the value of z is in [0..100] // OK too
    the value of x > 0 then z is 0 else z is 1

While language

    for all statement S: init(S) -- метка первого элементарного блока в S
    init([S]^l) = if S :: S1;S2 then init(S1) else l

    for all statement S: final(S) -- метка последнего элементарного блока в S
    e.g. final(while [b]^l do S) = l

    for all statement S: blocks(S) -- все элементарные блоки, на которые разбивается S

    flow(S) in Lab x Lab -- множество пар таких, что существует сценарий исполнения, приводящий к исполнению сначала первой метки, затем второй
    Может также быть представлено в виде flow graph (то есть, это отношение -- о том, как формально нужно строить flow graph
    flow (if [b]^l then S1 else S2) = flow(S1) U flow(S2) U {(l, init(S1)), (l, init(S2))}

    flowR(S) = { (b, a) | (a, b) in flow(S) }

    Abstract flow chart (блок-схемы, как в школе)

    Изолированный вход у программы -- нельзя перейти на точку входа, (l, init(S*)) not in flow(S*)).

    Изолированный выход -- из финальной метки никуда больше перейти нельзя. (программа, заканчивающаяся while'ом, не имеет изолированного выхода)

Intraprocedural analysis

    Анализ доступных выражений
        Для каждой точки программы определить, какие выражения необходимо вычислены и не будут изменены к этой точке.
        Позволяет избежать повторного вычисления выражения (возможно, нужно будет завести переменую для этого выражения, если оно считается в разных местах)

        X1         X2
          \       /
           X1 & X2
           [x = a]
              |
              X

            X = (X1 & X2 \ { expressions with an x }) U {subexpressions of that do not contain x }
                                    kill                                    gen

    kill -- то, что после этого блока нельзя переиспользовать
    gen -- то, что теперь можно переиспользовать, хотя раньше, возможно, было нельзя

    Достаточно формально определить зависимость выхода от входа и функции kill и gen для всех блоков

    В нотации AExp* -- любое подвыражение, AExp(a) -- любое подвыражение выражения a.

    Составляется система уравнений, связывающия AE_entry(l) и AE_exit(l), и решается итеративно (изменением множеств, пока не придём в неподвижную точку; теорема Тарского: если начинать с пустого множества и изменять его функцией f, то среди f(empty), f(f(empty)), f(f(f(empty))) есть неподвижная точка).

    Reaching definition
        Для каждой точки определить, какие назначения могли быть сделаны и не переписаны, пока мы шли к этой точке.
        В начале итеративного алгоритма считаем, что на входе программы все переменные определены, но неизвестно где.
        В этом случае нас интересует наименьшее решение.

    Very busy expression
        Обнаружение выражений, значения которых используются вне зависимости от потока управления
        Позволяет вычислить выражения до перехода в какую-то из веток, где оно в любом случае понадобится.
        Этот анализ идёт в обратном направлении, от выходов ко входам.

    Live variables
        Для каждой точки программы определить, какие переменные к этой точке "живы", то есть, могут быть использованы и не были переопределены.
        Полезно для dead code elimination.

Use-definition and definition-use chains

    Use-definition: each use is linked to all assignments that reach it

    Definition-use: each definition is linked to all uses that it can reach

О сходимости алгоритма

    