Антон Подкопаев -- anton@podkopaev.net
Даниил Березун -- daniil.berezun@jetbrains.com

Практика: пишем компилятор для языка с Pascal-like-синтаксисом.

В базовом языке будет:
	- арифметика (expressions)
	- локальные переменные с присваиванием
	- чтение из стандартного потока: read(v)
	- write(e)
	- if e then s else t
	- while e do s
	- s; t;
	- skip

	Система типов: всё целочисленное. Нужна формальная семантика.

	(базовый вариант предполагается в течение месяца)

	Потом появятся: функции, массивы

Проверка компилятора будет осуществляться с помощью формальной семантики.
Самый простой способ задать семантику -- написать интерпретатор.

Три разных способа задания семантики:

1) аксиоматический

2) денотационный

3) операционный -- описание интерпретатора
	Есть состояние некоторой абстрактной машины. Можно взять такое состояние:
	<i, o, f, s>

	i -- [Int]
	o -- [Int]
	f -- функция состояния переменных, Variable -> Int
	s -- программа, в виде statement

	Нужно написать набор правил вида

	<i, o, f, s1> -> <i1, o1, f1, skip>
	<i1, o1, f1, s2> -> <i2, o2, f2, skip>
	---
	<i, o, f, s1;s2> -> <i2, o2, f2, skip>

	Для || и && лучше использовать строгую (не ленивую) семантику -- проще будет с компиляторов.
	Можно написать в виде программы, а не только текст правил, но синтаксис пока не очень важен.
	Лучше всего этот этап сделать ко второй неделе.