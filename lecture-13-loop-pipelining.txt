Универсальный цикл -- все итерации не зависят друг от друга, самая высокая степень параллелизма -- выполнить все итерации одновременно, но есть ограничения на ресурсы, поэтому цикл можно хотя бы попробовать развернуть.

Разворот циклов увеличивает объём кода, что ухудшит работу с кэшем инструкций.

Устойчивое состояние цикла -- если внутри развёрнутого цикла есть минимальный временной интервал, в течение которого встречаются все инструкции итерации, то фактически время выполнения итерации становится равным длине устойчивого состояния, а пролог и эпилог можно не повторять.
Возможно, следует использовать устойчивое состояния для большего числа итераций, чтобы можно было выделить регистры и расположить инструкции без ожидания.

Цель программной конвейеризации
    1. Повысить производительность одной итерации в среднем (напрямую связано с размером устойчивого состояния)
    2. Маленький код (аналогично связано с устойчивым состоянием)

R[r1, ..., rk] -- количество ресурсов каждого вида у процессора

Устойчивое состояние -- потенциально то место, в котором ресурсы процессора используются максимально.

Степени свободы алгоритма: в какой момент начинать инструкцию внутри итерации; на какое число инструкций начала итераций сдвинуты друг относительно друга.

Пример:

    for (i = 0; i < N; i++) {
        *(p++) = *(q++) + c;
    }

    LD R4, O(R1++)
    | 1 такт
    ADD R5, R4, R3
    | 2 такта, потому что ADD выполняется два такта
    ST O(R2++), R5

    Плюс, из-за того, что p и q могут ссылаться на одно и то же место, добавляется зависимость между последней и первой инструкцией.

    К каждой зависимости добавим, на сколько итераций зависимость протянута:
    <x, y>: x -- через сколько итераций можно начинать зависимую инструкцию, 
            y -- через сколько тактов можно инструкцию начинать

    <x, y> -- s[j] - s[i] >= y - x * T, где T -- размер устойчивого состояния

    LD R4, O(R1++) ---+
    | <0, 1>          |
    ADD R5, R4, R3    | <1, 1>
    | <0, 2>          |
    ST O(R2++), R5 ---+

    Пример для зависимых итераций

    for (i = 2, i < N; i++) {
        A[i] = B[i] + A[i - 2]
    }

    A -- R1
    B -- R2
    i -- R10

  L:LD R3, O(R2++)
    LD R4, O(R1++)
    ADD R5, R3, R4
    NOP
    ST R5, O(R1 + 2)
    BL R10--, L

  L:LD R3, O(R2++)
     |
     |<0,1>     LD R4, O(R1++)
     |           | <0,1>    ^
    ADD R5, R3, R4          | 
     |<0,2>                 |<2,1> -- результат, который читается, получается от записи через две итерации
    ST R5, O(R1 + 2) -------+

    BL R10--, L

    Если в графе есть цикл, то нельзя спланировать устойчивое состояние меньше, чем за

    max ( sum { e in c } x_e / sum { e in c } y_e )
    c in loop

    Оптимальное решение можно получить линейным программированием, но это долго, и есть эвристический алгоритм, выдающий результат, достаточно близкий к оптимальному.

    Простой вариант алгоритма для случая без циклов в графе зависимостей

    T0 = max {j} (x_n,i RT_n(i, j) / x_j);
    for (T in T0, T0 + 1, ..., until all instruction are planned) {
        RT = [(i, j) |-> 0]
        for (all n in N -- по инструкциям цикла в приоритетном топологическом порядке) {}
            s0 = max { c = p -> n in E } (S[p] + d_e)
            for (s in {s0, s0+1, ..., s0 + T - 1}) {
                if (NodeScheduled(RT, T, n, s)) { break }
            }
            if (node not scheduled in the loop above) { break }
        }
    }

    Если есть циклы в зависимостях:

    n1
    | <x1, y1>
    n2

    (такие зависимости могут появляться даже транзитивно)

    S(n2) - S(n1) >= y1 - x1 * T
    S(n1) - S(n2) >= y2 - x2 * T

    S(n1) - y2 + x1 * T >= S(n2) >= y1 - x1 & T + S(n1)

    Будем находить в графе компоненты сильноя связности и планировать, используя их.

    (алгоритм на фото)

В рассмотренных примерах внутри итерации не было control flow. Если зависимости по управлению не слишком большие, то достаточно предикатных инструкций, если они есть в архитектуре -- и тогда зависимости по управлению переходят в зависимости по данным.
Предикатные инструкции также могут помочь избавиться от пролога и эпилога.
Кроме того, может помочь для планирования чередующихся итераций блок смещающихся регистров -- изменяя его, можно аппаратно переименовывать регистры.

register alias table

Алгоритм Томасуло (переименование регистров)
reservation table
+reorder buffer -- exceptions and branch prediction