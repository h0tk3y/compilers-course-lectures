Продолжаем про семантики.

Пример параллелизма:

    [x] = [y] = 0 // две локации в памяти

    [x] = 1  || [y] = 1 // запускаем два потока -- вертикальные
    a := [y] || b := [x] // два регистра

    Какие значения для a и b можем получить? Все пары кроме (0, 0) можем получить чередованием.
    Пару (0, 0) можем получить из-за железа (каждый поток прочитал из кэша разных ядер).
    Другой вариант -- компилируем программу на C++ с помощью GCC, и он оптимизирует независимые обращения к памяти.

    Weak memory models -- модели памяти, описывающие семантики, позволяющие получать любые результаты, которые может выдать машина.

Аксиоматическая семантика:

    Семантика задаётся некоторым количеством аксиом. 

    [| . |] : Programs -> Graphs
                         where nodes: memory operations (load, store, read-modify-write)
                         (пример read-modify-write -- CAS: cas(x, 0, 1) атомарно выполнится, если в x был 0, и запишет 1)
                         edges: memory relations on operations above

    Для примера выше

    sb -- sequenced before
    asw -- additional-synchronize with
    rf -- read from -- оперируют над одной локацией, и значения согласованы
    mo -- memory order

            w x 0 
          /   | sb
         /    |
      mo|   w y 0
        |  /  |  \ asw, mo
      w x 1   |   w y 1
             /rf  |  sb  
       r y 0      r x 0

    Тут мы можем построить ещё три других графа, соотвествующих другим исполнениям.
    Для таких графов мы можем проверить выполнение набора аксиом, и если они выполняются, то такой граф попадает в множество значений
    введённой аксиоматической семантики.

    // В стандарте C/C++ описывается семантика языка. Concurrency описана в аксиоматическом виде в стандарте C++11.
    // Там описаны операции над atomics (e.g. atomic<int>), и операции с ними бывают: relaxed, acquire, sc, ...
    // Обычные операции с переменными эвкивалентны операциям с модификатором non-atomic.
    // relaxed -- обычные операции в целевой машине (в частности, ARM, x86, PowerPC)
    // acquire/release -- операции с барьером памяти (бывает, неполным), в x86 -- load с барьером, store без.
    // sc -- последовательная согласованность, если в программе все обращения хотя бы sc, то вся программа будет 
    // выполняться последовательно согласованно (на самом деле нет, там всё сломано).
    // Всё это нужно для lock-free алгоритмов, и если не знать досконально стандарт, то на C++ такие вещи лучше просто не писать.
    // Наличие data race между неатомарными операциями приводит к undefined behavior.
    // see: Relaxed Separation Logic: A program logic for C11 Concurrency

    Sequentially consistent models -- модели, в которых исполнения варьируются только в рамках чередования продвижения потоков.

    // В ARM-процессорах есть операции записи, локальные для процессора.

    Семантики должны удовлетворять:
    * целевым платформам
    * оптимизациям компилятора
    * здравому смысле -- не должна разрешать слишком много

    Model checking -- область, близкая к промышленности. Доказательство свойств для систем через построение модели, достаточно близкой
    к системе, и проверку свойств на ней. Наличие аксиоматической семантики упрощает проверки SAT-солвером -- проще построить формулы.

    