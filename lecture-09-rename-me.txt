Короткий рассказ про парсинг -- это нужно знать

    Бывает восходящим и нисходящим, одноуровневым и двухуровневым.
    Нужно знать, как устроено и какие виды бывают, вплоть до булевых грамматик (не включая их).

    Нужно уметь построить автомат по грамматике -- обычный со стеком, LL, LR, SLR.
    Нужно знать предикативный анализ и парсер-комбинаторы.

Семантический анализ

    Делается из-за того, что язык на самом деле не контекстно-свободный и в нём есть неконтекстные зависимости.

    Самый простой пример -- выражения:

        Expr := v | E + E | E * E
        Это никогда не будет LL(k), если переменные и константы могут быть не в один символ.
        Если они могут быть длиннее, то всегда можно дать идентификатор длиннее, чем k, но
        тогда можно использовать лексер.

    Компилятор C++ долго воспринимал '<<' как оператор сдвига даже в templates, потому что
    был двухуровневый, потом переписали на предикативный анализ.

    Самый простой пример семантического анализа -- проверка определённости идентификатора, и уже это
    нельзя выразить синтаксическим анализом -- a^n b^m c^n d^m не контекстно свободный.
    Кроме этого проверять можно правильное использование ключевых слов, существование типов и т.д.

    При семантическом анализе также можно проверять область видимости -- статическую и динамическую.
    Статическая -- иерархическая по коду и скоупам.
    Динамическая -- что-то похожее на Lisp, связывает текущую переменную с последним её объявлением в рантайме. Похоже на глобальные переменные, но с правилами доступа, и явно поддерживаются последние объявления переменных в рантайме.

    // Дополнительным заданием может попасться типизация или классы.
    // Ожидается, что компилятор будет в выражении `let x = 3 in y = 5` выдавать предупреждение.
    // Кроме того, обязательно правильно сообщать об ошибках и избегать undefined behavior.

    Семантический анализ обычно делается с деревом. При этом часто можно не делать отдельный проход для проверки объявленных имён, можно сделать с помощью атрибутов (если парсер их будет поддерживать). Иначе делаем обход дерева с поддержкой таблицы символов/типов. Другой подход -- сделать этот анализ в коде для стековой машины.

Немного о типах

    Что такое тип, сложно сказать, обычно типы определяются набором значений, вещей, которые с ними можно делать, размером и так далее.

    add $r1, $r2, $r3 -- в ассемблерном коде тут даже не целые числа, а биты, и проверка что, например, указатель не складывается с числом, должна делаться раньше на этапе type checking.

    Type checking VS type inference
    Проверка относится к полностью типизированной программе, для которой только проверяется корректность. 
    Вывод типов происходит на неполностью типизированной программе.
    Но эти две вещи часто отождествляются, потому что обе делаются с помощью набора правил вывода.

    Типовая система должна быть согласованной (sound) -- это утверждение, что если тип выведен во время компиляции, то и в runtime тип должен быть именно таким.

    Г |- e1:T0,     Г U {x : T0} |- e2:T1
    -------------------------------------
       Г |- (let x := e1 in e2):T1

    Что не так с этим правилом вывода?
    Оно хорошо работает, если только нет подтипов.

    Исправляется так:

    Г |- e1:T0      Г U {x : T0} |- e2:T1        T0 <= T
    ---------------------------------------------------- // ??? правда ли, что тут T0 <= T только для того, чтобы не типизировать лишнее
              Г |- (let (x:T) := e1 in e2):T1            // ?? не должно ли тут быть x:T0?

    Как типизировать while? Общий тип для всех его точек выхода.

    Вызов функции:

        M, Г |- f : T1' -> ... Tn' -> R
        M, Г |- e1 : T1
        ...
        M, Г |- en : Tn
        T1 <= T1'
        ...
        Tn <= Tn'
        --------------------------------
        M, Г |- f(e1, ..., en) : R

    Если функции с ресиверами, то нужно ещё проверять наличие этой функции в таблице у типа ресивера.

Немного о рантайме

    Важная его часть -- сборка мусора, и нам придётся её реализовывать.

    Организация памяти -- выравнивание, padding, запаковывание (заполнение фрагментированных частей для экономии памяти, косвенная адресация).

    Типичное распределение памяти:
        Код
        Статические данные
        Куча
        v
        unallocated
        ^
        Стек

    // Последовательность функций можно представить в виде дерева активации.
    Для каждого стекфрейма можно заранее вычислить его максимальный размер (если нет динамической аллокации на стеке).

    TODO: связи доступа, дисплеи -- нужны для вложенных функций

