У нас есть машина, которая описывается как M = <R, T>
R -- вектор, который говорит о том, сколько есть каких ресурсов (сумматоров и так далее)
T -- инструкции и их время работы

Планирование кода для базового блока

Таблица резервирования:
RT_i_j_k -- сколько ресурсов типа i занято на k-м такте работы j-й инструкции

Граф зависимостей

G = <V, E>

V -- инструкции базового блока, E -- зависимости

Если есть инструкции 

    LD R0, #101
    ADD R3, R0, R1

, то они будут соединены ребром, на котором дополнительно будет число -- через сколько инструкций вторая может идти после первой.

Пример такого графа, будем считать, что ADD и MUL дают результат за один такт, LD -- за два, ST -- за один.
Рассмотрим базовый блок:

1   LD R2 0(R1)
2   ST 4(R1), R2
3   LD R3, 8(R1)
4   ADD R3, R3, R4
5   ADD R3, R3, R2
6   ST 12(R1), R3
7   ST 0(R7), R7

Рёбра:

    1 -(2)-> 2
    1 -(2)-> 5
    3 -(2)-> 4
    4 -(5)-> 5
    5 -(1)-> 6

Такой граф нужно строить консервативно: если мы в программе делаем

    [x] := 1
    [y] := 1

, то нам следует предполагать, что может быть x == y, и поэтому операции с адресами тоже должны влиять на граф зависимостей.
0(R1), 4(R1) и 8(R1) -- точно разные числа, поэтому такие рёбра не добавляем. Добавляем:

    1 -> 7
    2 -> 7
    3 -> 7

Планирование осуществляется в порядке топологической сортировки. Но при этом для одной и той же программы топологических порядков может быть несколько. Оптимальное по числу тактов решение выбирать долго. Можно применить некоторое количество эвристик:

Одна из эвристик -- найти в графе критический путь (самый длинный в смысле суммы на дугах) и спланировать сначала его (быстрее, чем максимальная длина зависимостей, всё равно выполниться не получится), а затем всё остальное. Можно смотреть на частоту использования ресурсов. И, чтобы избавиться от неоднозначности, можно учитывать порядок в программе.

Для алгоритма list scheduling будем строить таблицу резервирования для базового блока:

    RT := [(i, j) -> 0]
    for n in N(base block), topsorted:
        // find a moment when all the dependencies of (n) are finished
        s = max { e = (p -> n) in E } (S_(p) + d_e) // where d_e -- edge label in dependency graph
        while (exists i: RT[s + i] + RT_n[i] > R) // where R -- machine constant, available number of each resource
        S_n := s
        for all i:
            RT[s + i] := RT[s + i] + RT_n[i]

Теперь о глобальном планировании, когда есть граф базовых блоков.

Рассмотрим программу

    if (a != 0) {
        c = b;
    }
    e = d + d;

Как мы её можем скомпилировать: один из вариантов

    if (a == 0) goto L
    c = b;
    L: e = d + d;

    В машинном коде:

0   LD R6, 0(R1) + NOP     a: 0(R1)  
2   BEQZ R6, L             b: 0(R2)  
3   LD R7, 0(R2) + NOP     c: 0(R3)  
5   ST 0(R3), R7           d: 0(R4)
6 L:LD R8, 0(R4) + NOP     e: 0(R5)
8   ADD R8, R8, R8
9   ST 0(R5), R78

    (машина такая же, какая была раньше)

    Для старых процессоров нужно было планировать инструкции вручную и расставлять NOP'ы, иногда ещё и после инструкций перехода.

    Базовые блоки:

3   0   LD R6, 0(R1) + NOP  
    2   BEQZ R6, L         \
                            |
    |                       |
    V                       |
                            |
3   3   LD R7, 0(R2) + NOP  |  
    5   ST 0(R3), R7        |
                            |
    |                       |
    v                      /
                          v
4   6 L:LD R8, 0(R4) + NOP
    8   ADD R8, R8, R8
    9   ST 0(R5), R78      

    Если мы можем исполнять две инструкции чтения за один раз, то мы можем оптимизировать программу так:
    6 объединить с 1, убрать NOP после 6

3   0   LD R6, 0(R1) | LD R8, 0(R4) + NOP
    2   ADD R8, R8, R8 | BEQZ R6, L 
                            |
    |                       |
    V                       |
                            |
3   3   LD R7, 0(R2) + NOP  |  
    5   ST 0(R3), R7        |
                            |
    |                       |
    v                      /
                          v
1   9   ST 0(R5), R78      

    Затем можно переместить 3 после 0 вместо NOP:

3   0   LD R6, 0(R1) | LD R8, 0(R4)
    3   LD R7, 0(R2) + NOP
    2   ADD R8, R8, R8 | BEQZ R6, L 
                         |
    |                    |
    V                    |
                         |
3   5   ST 0(R3), R7     |
                         |
    |                    |
    v                   /
                       v
1   9   ST 0(R5), R78      

    Если мы можем делать ещё и две записи параллельно, то можно в случае прохождения через 5 присоединить к ней 9:

    3   0   LD R6, 0(R1) | LD R8, 0(R4)
    3   LD R7, 0(R2) + NOP
    2   ADD R8, R8, R8 | BEQZ R6, L 
                         |
    |                    |
    V                    |
                         |
3   5   ST 0(R3), R7 | ST 0(R5), R78      
                         |
    | (уходит ниже)      |
    |                   / 
    |                  v  
1   9 ST 0(R5), R78      
    |
    |
    v                   

Полезные определения:

    Доминирование и постдоминирование в графах.

    |
    v
    A 
    | \
    |  B
    | /
    v
    C

    A доминирует над C, если любой путь исполнения, прошедший через С, проходит затем и через A.
    C Постдоминирует над A -- путь через C обязательно проходит через A до самой вершины.

    Если множества доминируемых и постдоминируемых вершин у X и Y совпадают, то X и Y называются эквивалентными по управлению.

Восходящее перемещение кода

    Перемещение инструкции в предыдущий по потоку управления базовый блок.

    +-------+
    |       | dst
    +-------+
        |
        v
    +-------+
    |       | src
    +-------+      

    Перенос инструкции не должен менять семантику

    Нисходящее -- аналогично.

    После перемещения нужно перестраивать граф зависимостей.

Пример, восходяшее и упреждающее восходяшее:

    Область в графе потока управления -- подграф с единственной точкой входа.
    Если исполняется инструкция из области, то исполняется и первая

    Алгоритм похож на тот, что был раньше, только рассматривать будет не базовые блоки, а области
    Планирование на основе областей. Region scheduling. (фото доски)

Наивысший приоритет при планировании должен быть у циклов.

    При этом цикл может быть в том числе одним базовым блоком или одной областью.
    В случае с циклами тело может быть небольшим -- пара инструкций, сильно между собой зависящих.
    Но если несколько последовательных итераций могут выполняться параллельно, то имеет смысл развёртывание цикла:

    for (i = 0; i < N; i++) {
        S(i);
    }

    После трансформации:

    for (i = 0; i < N - k; i++) {
        S(i);
        S(i + 1);
        S(i + 2);
        S(i + 3);
    }
    for (i = N-k; i < N; i++) {
        S(i);
    }

Бывают процессоры с динамическим планированием (суперскалярные) и без. Если его нет, то задача компилятора -- сделать код наиболее эффективным для исполнения, иначе -- достаточно помочь, имея при компиляции много времени.