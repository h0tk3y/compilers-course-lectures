Сегодня будем обсуждать:

    * как компилировать выражения из стековой машины в x86
    * парсинг (в очень прикладном варианте, и будем говорить про парсер-комбинаторы)

Про компиляцию для x86

    Использовать будем символический стек, состоящий из какого-то количества регистров и затем программного стека.
    В нём будет находиться только то, что не вычислено в текущем выражении.
    Для операций со значениями в символическом стеке, лежащими вне регистров (в программном стеке) зарезервируем два регистра.

Про парсинг

    type Parser a -- объектам этого типа можно скормить строчку и получить объект типа a и неразобранный суффикс
                  = String -> [(a, String)]

    lit p s = \s' -> if (String.prefix s s') then [(s, String.chop (length s') s')] else []

        e.g. lit p "read"

    Мы хотим, чтобы Parser был монадой.

    return a = \s -> [(a, s)]
    (>>=) p f = \s -> concat [(f x) s' \(x, s') <- p s]