В курсах компиляторов обычно мало говорят про семантики, но много говорят про синтаксический анализ.
Особенно полезно для проверки корректности, потому что подход с написанием интерпретатора далеко не самый простой и практичный,
и мы обычно хотим лучше понимать, как работают программы на нашем языке.

Пока что наш язык: 
1) Expr E ::= Var V | Const C | UnaryOperator E | BinaryOperator E1 E2
2) Statement S ::= Skip | S1; S2 | if e then s1 else s2 | while e do s | v := E | read(v) | write(v)

Это фактически синтаксис: так бы выглядели узлы абстрактного синтаксического дерева.
Про неоднозначность: 'while (v) do s1; s2' -- как это парсить, мы пока не вникаем, потому что пока что у нас
абстрактный синтаксис, не имеющий отношения к текстовому представлению. Оно может быть любое, и нас пока не
интересует, как из него получаются деревья.

3) Program ::= S (программа выглядит просто как какой-нибудь из операторов)

Теперь займёмся семантикой нашего языка. В нашем случае семантика -- это функция.

[| _ |] : E -> ( )      // что она ставит в соответствие? Значения -- целые числа, но ещё есть состояние программы
[| _ |] : E -> (T -> Z) // здесь T -- это состояние программы, значения всех переменных на данный момент

[| C |] = \s . c        // c и C -- разные вещи, C -- из синтаксиса, а c -- целое число
[| V |] = \s . s x      // значение переменной берётся из состояния программы
[| A _ B |] = \s . ([| A |] s) _ ([| B |] s) // берём две функции из состояния, применяем их к текущему состоянию, оперируем с результатами

Сейчас зададим семантику строгой: чтобы посчитать значение выражения, всегда нужно посчиитать все его части.

_def_ 
	Use : E -> 2^V -- все используемые в выражении переменные
		Use C = {}
		Use V = {V}
		Use (A _ B) = (Use A) U (Use B)

_Утверждение_

	S1, S2 -- состояния, E -- выражение
	Если S1 | Use E = S2 | Use E, то 
		 [| E |] S1 = [| E |] S2

	Доказывать утверждения про семантику мы обычно будем по индукции

	_Доказательство_ (индукция по структуре)

	[| C |] S1 = [| C |] S2 = c (по определению [| C |])
	[| V |] S1 = S1 V =(по условию)= S2 V = [| V |] S2

	Переход:

	[| A _ B |] S1 =def= [| A |] S1 _ [| B |] S1 =(по индукционному предположению)= [| A |] S2 _ [| B |] S2 = [| A _ B |] S2

	Индукционным предположением мы можем пользоваться только потому, что каждая часть становится меньше, чем исходное выражение.

_Утверждение_ (строгость)

	Если V in Use E и [| V |] = undefined, то [| E |] = undefined

	(доказывается структурной индукцией)

	Всё, что входит в большое выражение, должно быть определено. При этом значение выражения может и не зависеть от какой-то части.
	Например, для выражения "false && x" значение не будет зависеть от x, но строгая семантика не определена, если не определён x.

Если мы хотим нестрогую семантику, то нужно описывать случаи операторов:

	[| A * B |] = \s . [v // это означает выбор приоритетов сверху вниз
						  0, если [| A |] s == 0,
						  [| A |] s * [| B |] s otherwise
					   ]

Перейдём к семантике для операторов самого языка. Сначала будем обсуждать операционную семантику.

Семантика большого шага (естественная семантика, big step, natural)

	Наш домен -- множество конфигураций C,
	Введём бинарное отношение ((-> s) subset C^2, оно же (->) subset S x C x C)

	C = (V -> Z) x Z* x Z* = <s, i, o>

	Аксиомы:

		c -(skip)-> c [Skip_BS] (в квадратных скобках название правила, BS -- big step)

		<s, i, o> -(V := E)-> <s [ x |-> [|E|] s ], i, o> [Assign_BS] (замена в отображении s одной точки)

		<s, i:is, o> -(read(x))-> <s [ x |-> i ], is, o> [Read_BS] (i:is -- выделение головы списка)

		<s, i, o> -(write(E))-> <s, i, ([|E|] s) : o>

	Правила вывода

	*	c -(s1)-> c', c1 -(s2)-> c''
		---------------------------- [Seq_BS]
			 c -(s1; s2)-> c''


	*			c -(s1)-> c'
		------------------------------, [|e|] s != 0 [IfTrue_BS], аналогично [IfFalse_BS]
		c -(if e then s1 else s2)-> c'


	*   
		------------------------------, [|e|] s = 0 [WhileFlase_BS] (это не аксиома, потому что у неё есть условия применения)
			c -(while E do s)-> c


	*	  c -(s)-> c', c' -(while e do s)-> c''
		----------------------------------------, [|e|] s != 0
		        c -(while e do s)-> c''

	Семантика программы

		С0 = <(\s . undefined), i, []>
		C' = <s, [], o> (тут мы говорим, что программа должна съесть весь свой вход)
		[| P |] = C0 -(P)-> C' (далее мы покажем, что если определено C0 и P, то C определяется однозначно)

	Пример для конкретной программы

		read(k);
		n := 0;
		while k > 0 do
			n : = n + k;
			k := k - s  
		;    
		write(n)

						                                                                                         ...
                                                                                               --------------------------------------
                                                    c1 -(n:=0)-> c2@<k|->2, n|->0, [], []>     c2 -(while k > 0 do s5); write(n)-> c4
		-----------------------------------------   ---------------------------------------------------------------------------------
		<top, 2, []> -(read(k))-> <k|->2, [], []>                         c1@<k|->2, [], []> -(s2@s3;s4)-> c3
		-------------------------------------------------------------------------------------------------------------------------------
		                         					<top, 2, []> -(s0)-> c3

	_Утверждение_ (детерминированность)

		Если C -(S)-> C' и
       		 C -(S)-> C'', то
       	     C' = C''

    	_Доказательство_ (индукция по размеру дереву вывода)

    		Аксиомы -- очевидно, потому что они введены однозначно, и в них нет никакой декомпозиции, поэтому базу мы получаем автоматически.

			C -(skip)-> C <-(skip)- C
			(и для остальных аксиом)

    		Переход:

			C -(S1;S2)-> C
			C -(S1)-> C' -- размер дерева S1 меньше, и по предположению S1 всегда приводит C к C'
			C' -(S2)-> C'' -- аналогично

			C -(if e then s1 else s2)-> C'
			В обоих случаях для e размеры деревьев s1 и s2 меньше, поэтому в обоих случаях можно применять предположение индукции

			Для while размер дерева вывода для тела меньше потому, что даже если вывод бесконечный, то тело будет выше.
			Или можно говорить, что для бесконечных деревьев семантики программы нет.

	Пока что всё просто, а нетривиальные вещи начинаются, когда рассуждать о семантике приходится для сколько-нибудь сложного языка. При этом в семантику
	дополнительно включают, например, количество выделенной памяти программы. И нужно это для того, чтобы показать, например, что оптимизации не
	изменяют семантику.

Семантика языка C не задана в адекватном виде и не определна во многих случаях, например:

	int x = 1;
	return (x = 2) && (x = 3);

(тут GCC и clang выдадут разные результаты)

С формальной семантикой проще рассуждать об эквивалентности программ:

	forall p1, p2: p1 ~ p2 <=> [| p1 |] = [| p2 |] (в смысле отображения C0 -> C')

	Программы, не имеющие семантики тоже эквивалентны, и нас даже не интересует, почему каждая из них не имеет семантики.

	Что с эквивалентностью операторов? Сам по себе оператор несёт не очень много смысла. "x := z + y" -- всё зависит от конфигурации.
	Чтобы можно было всё-таки об этом рассуждать, делают такой трюк:

	forall s1, s2: s1 ~ s2 <=> forall (p | s1 in p): p ~ p[s1 := s2] (здесь делается замена одного оператора в программе на другой)

	(x := x) !~ skip, потому что (x := x) ничего не делает, только если определён x.

	А вот (s1; s2); s3 ~ s1; (s2; s3) (для доказательства нужно рассмотреть дерево разбора семантики, разобрать его на части и собрать другое).

	while e do s ~ if e then s else while e do s
	while e do s ~ if e == 0 then skip else while e do s
	Это называется раскруткой циклов, и её используют для оптимизации. В нашей семантике можно показать, что это валидная оптимизация.

	Очевидно, можно доказать, что s1;s2 !~ s2;s1.

	