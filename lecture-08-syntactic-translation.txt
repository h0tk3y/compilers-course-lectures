Синтаксически управляемая трансляция

    Трансляция прямо во время синтаксического анализа.
    Может понадобиться для однопроходной компиляции (было актуально раньше: не держать в памяти большое синтаксическое дерево)
    В языках C и Pascal нельзя использовать функцию до её объявления именно из-за однопроходной компиляции.

    Кроме того, это ещё один достаточно интересный подход к вычислениям на деревьях.

    Пример:
    Продукция   | Семантическое правило
    E -> E1 + T | E.code = E1.code || T.code || '+'

    Будем работать с синтезируемыми и наследуемыми атрибутами.

    Для вычисления атрибутов можно построить граф зависимостей. Для вычислений его можно топологически отсортировать.
    Кроме того, построение такого графа позволяет проверить, есть ли циклические зависимости.

    L-атрибутные грамматики -- в наследуемых атрибутах есть только зависимости слева-направо, но не наоборот.
    Это задаёт порядок вычислений, позволяющий избежать циклов.
    L-атрибутные грамматики соответствуют LL-разбору.

    S-атрибутные грамматики -- без наследуемых атрибутов.
    Соответствуют LR-разбору.

    Синтаксически управляемые схемы трансляции
    E -> E1 + { print '+'} T -- можно в любое место правил добавлять код.

    Постфиксная СУТ -- все действия расположены в конце продукции

    B -> X {a} Y

    Действия могут выполняться:
    при восходящем -- когда X на вершине
    при нисходящем -- перед раскрытием Y
 
    Чтобы избавиться от неоднозначности можно избавиться сначала полным разбором в дерево с последующим выполнением всех действий

    Offtopic

    Repmin

        data Tree = Leaf Int | Node Tree Tree
            deriving Show

        Нужно перестроить дерево за один обход так, чтобы значения в листьях стали равны минимальному значению в листе.

        repmin' :: (Int, Tree) -> (Int, Tree)

    В Haskell: uuagc -- компилятор атрибутных грамматик

Промежуточный код и его представление

    Булевы выражения

        Вычисление бывает полное, сокращённое, можно использовать поток выражения.

    Backpatching

        Метод, позволяющий вставить метки после генерации кода.

        makelist(i)
        merge(p1, p2)
        backpatch(p, i)

Типы

    Помогают в обеспечении семантической корректности.
    Могут быть использованы в трансляции:
    1) выбор версии арифметического оператора
    2) размер памяти для переменной
    3) выравнивание адресов переменных

    Sound type system: не допускает некорректные программы